
/*
 * Generated by TPTC - Translate Pascal to C
 *     Version 1.7g 05-02-88   (C) 1988 S.H.Smith
 */


/*
 * TPTCSYS.PAS - System unit for use with Turbo Pascal --> C Translator
 *
 * (C) 1988 S.H.Smith (rev. 07-Apr-88)
 *
 * This unit is compiled to create 'TPTCSYS.UNS' and 'TPTCSYS.UNH', which
 * are automatically loaded on each TPTC run.   It defines the predefined
 * environment from which programs are translated.
 *
 * Compile with:
 *    tptc tptcsys -L -NU
 *
 * Note: the special 'as replacement_name' clause used in some cases.
 * When present, this clause causes the replacement_name to be used in
 * place of the original name in the translated output.
 *
 * Note: the special 'symtype <typename>' clause forces the declared symbol 
 * type to the specified typename.  This is used when adding detail to 
 * standard builtin identifiers (such as text).
 *
 * Lines starting with "\" are passed directly to the C object file
 * without any translation.
 *
 */ 

/* Unit tptcsys */ 



   
#define IN_TPTCSYS  /* globals defined here */
#include <TPTCSYS.UNH>


  #include <stdlib.h>
  #include <string.h>
  #include <stdarg.h>
  #include <dos.h>
  #include <conio.h>
  #include <ctype.h>
  #include <alloc.h>


   /*
    * String/character concatenation function
    *
    * This function takes a sprintf-like control string, a variable number of
    * parameters, and returns a pointer a static location where the processed
    * string is to be stored.
    *
    */ 

  string scat(string control, ...)
  {
     static char buf[STRSIZ];
     char buf2[STRSIZ];
     va_list args;

     va_start(args, control);     /* get variable arg pointer */
     vsprintf(buf2,control,args); /* format into buf with variable args */
     va_end(args);                /* finish the arglist */

     strcpy(buf,buf2);
     return buf;                  /* return a pointer to the string */
  }


   /*
    * string build - like scat, sprintf, but will not over-write any
    *                input parameters
    */ 
  void sbld(string dest,
            string control, ...)
  {
     char buf[STRSIZ];
     va_list args;

     va_start(args, control);     /* get variable arg pointer */
     vsprintf(buf,control,args);  /* format into buf with variable args */
     va_end(args);                /* finish the arglist */

     strcpy(dest,buf);            /* copy result */
  }



   /*
    * spos(str1,str2) - returns index of first occurence of str1 within str2;
    *    1=first char of str2
    *    0=nomatch
    */ 
   
integer      spos(char *       str1,
                  char *       str2)
        /* returns the position of a substring within a longer string */ 
   { 
     string res;
     res = strstr(str2,str1);
     if (res == NULL)
        return 0;
     else
        return res - str2 + 1;
   } 


   /*
    * cpos(str1,str2) - returns index of first occurence of c within str2;
    *    1=first char of str2
    *    0=nomatch
    */ 
   

integer      cpos(char         c,
                  char *       str2)
        /* returns the position of a character within a string */ 
   { 
     string res;
     res = strchr(str2,c);
     if (res == NULL)
        return 0;
     else
        return res - str2 + 1;
   } 


   

char *       copy(char *       s,
                  integer      from,
                  integer      len)
        /* copy len bytes from the dynamic string dstr starting at position from */ 
   { 
     static char buf[STRSIZ];
     buf[0]=0;
     if (from>strlen(s))       /* copy past end gives null string */
        return buf;

     strcpy(buf,s+from-1);    /* skip over first part of string */
     buf[len] = 0;            /* truncate after len characters */
     return buf;
   } 

   

void         move(pointer      tomem,
                  pointer      fmmem,
                  word         bytes)
   { 
     while (bytes--)
        *tomem++ = *fmmem++;
   } 

   

void         fillchar(pointer      dest,
                      integer      size,
                      char         value)
   { 
     while (size--)
        *dest++ = value;
   } 

   

integer      length(char *       s)
   { 
     return strlen(s);
   } 

   

char *       ctos(char         c)
        /* convert a character into a string */ 
   { 
     static char s[2];
     s[0] = c;
     s[1] = 0;
     return s;
   } 

   

char         upcase(char         c)
   { 
     if (islower(c))
        c = toupper(c);
      return c; 
   } 


   /*
    * This function operate like fscanf except for an added control
    * code used for full-line reads.
    *
    */ 
  int tscanf(text *fd,
             string control, ...)
  {
     va_list args;
     string arg1;
     int     i;

     va_start(args, control);     /* get variable arg pointer */

     /* process special case for full-line reads (why doesn't scanf allow
        full-line string reads?  why don't gets and fgets work the same?) */
     if (*control == '#') {
        arg1 = va_arg(args,string);
        fgets(arg1,STRSIZ,fd->filevar);
        arg1[strlen(arg1)-1] = 0;
        return 1;
     }

     /* pass the request on to fscanf */
     i = vfscanf(fd->filevar,control,args);    /* scan with variable args */
     va_end(args);                             /* finish the arglist */

     return i;                        /* return a pointer to the string */
  }


  void tprintf(text *fd,
               string control, ...)
  {
     va_list args;
     va_start(args, control);               /* get variable arg pointer */
     vfprintf(fd->filevar,control,args);    /* scan with variable args */
     va_end(args);                          /* finish the arglist */
  }



   /* 
    * Standard procedures and functions
    *
    */ 

   

real         sqr(real         n)
   { 
      return n * n; 
   } 

   

longint      trunc(real         r)
   { 
      return (longint) (r); 
   } 

   

real         round(real         r)
   { 
      return (real) ((longint) (r + 0.5)); 
   } 

   

integer      pred(integer      b)
   { 
      return b - 1; 
   } 

   

integer      succ(integer      b)
   { 
      return b + 1; 
   } 

   

integer      ord(char         c)
   { 
      return (integer) (c); 
   } 

   

word         hi(word         w)
   { 
      return w >> 8; 
   } 

   

word         lo(word         w)
   { 
      return w & 0xFF; 
   } 

   

void         inc(byte *       b)
   { 
      *b = *b + 1; 
   } 

   

void         dec(byte *       b)
   { 
      *b = *b - 1; 
   } 

   

longint      memavail(void)
   { 
     return coreleft();
   } 

   

longint      maxavail(void)
   { 
     return coreleft();
   } 

   

void         dispose(pointer      ptr)
   { 
     free(ptr);
   } 

   

void         pfreemem(pointer      ptr,
                      integer      size)
   { 
     free(ptr);     
   } 

   

char *       paramstr(integer      n)
   { 
     return tptc_argv[n];
   } 

   

void         delete(char *       s,
                    integer      posit,
                    integer      number)
   { 
     strcpy(s+posit-1,s+posit+number-2);
   } 

   

void         val(char *       s,
                 real *       res,
                 integer *    code)
   { 
      *res = (real) atof(s); 
      *code = 0; 
   } 

   

real         dint(real         r)
   { 
      return (real) ((longint) (r)); 
   } 


   /*
    * These will probably change when binary file translation is implemented
    *
    */ 

   

boolean      eof(text *       fd)
   { 
     return feof(fd->filevar);
   } 

   

void         flush(text *       fd)
   { 
     fflush(fd->filevar);
   } 

   

void         close(text *       fd)
   { 
     fclose(fd->filevar);
   } 

   

void         assign(text *       fd,
                    char *       name)
   { 
      strcpy(fd->fname,name); 
   } 

   

void         reset(text *       fd)
   { 
     fd->filevar = fopen(fd->fname,"r");
     ioresult = (fd->filevar) == NULL;
   } 

   

void         rewrite(text *       fd)
   { 
     fd->filevar = fopen(fd->fname,"w");
     ioresult = (fd->filevar) == NULL;
   } 

   

void         append(text *       fd)
   { 
     fd->filevar = fopen(fd->fname,"a");
     ioresult = (fd->filevar) == NULL;
   } 

   

void         settextbuf(text *       fd,
                        pointer      buffer,
                        word         size)
   { 
     setvbuf(fd->filevar,buffer,_IOFBF,size);
   } 

   

void         seek(text *       fd,
                  word         rec)
   { 
        /* stubbed */ 
   } 

   

boolean      seekeof(text *       fd)
   { 
        /* stubbed */ 
   } 



   /* 
    * Additional procedures called by translated code 
    *
    */ 

  setrec setof(byte element,...)
  {
     /* stubbed */
  }

   

boolean      inset(byte         item,
                   setrec       theset)
   { 
        /* stubbed */ 
   } 


/*
 * Top-level initialization
 *
 */ 

void tptcsys_init(int argc, char **argv)
{
   static char unit_initialized = 0;
   if (unit_initialized) return;

   unit_initialized = 1;


  tptc_argv = argv;
  paramcount = argc;
  cseg = _CS;
  sseg = _SS;
  dseg = _DS;
 /* input.filevar = stdin; */
 /* output.filevar = stdout; */
}



